---
title: "Durable Objects"
description: "Deep dive into DurableThread and DurableAgentBuilder - the stateful foundation of AgentBuilder"
---

## Overview

AgentBuilder uses Cloudflare Durable Objects to provide stateful, distributed execution for AI agents. Each Durable Object is a single-threaded, globally unique instance with its own SQLite database, ensuring consistency and eliminating the need for external database management.

<Card title="Why Durable Objects?" icon="database">
- **Isolated SQLite per thread** - No shared database to manage
- **Global uniqueness** - Each thread ID maps to exactly one instance
- **Automatic persistence** - State survives crashes and redeployments
- **Edge deployment** - Low-latency access from anywhere in the world
- **Transactional consistency** - No race conditions or concurrent access issues
</Card>

## Two Durable Objects

AgentBuilder uses two types of Durable Objects, each with a specific purpose:

### DurableThread

**Purpose:** Manages individual conversation threads

Each thread is an isolated Durable Object instance with:
- SQLite database for messages, logs, and execution state
- Turn-based execution state machine
- Tool call queue and execution history
- WebSocket connections for real-time streaming

**Instance per:** Each unique thread ID

```typescript
// Creating a thread (internally handled by framework)
const threadId = crypto.randomUUID()
const threadStub = env.AGENT_BUILDER_THREAD.get(
  env.AGENT_BUILDER_THREAD.idFromString(threadId)
)
```

### DurableAgentBuilder

**Purpose:** Global metadata and thread registry

A singleton Durable Object that manages:
- Thread metadata (agent_id, user_id, created_at, tags)
- Thread listing and filtering
- User-thread associations
- Global configuration

**Instance per:** One per application (singleton)

```typescript
// Accessing the singleton (internally handled by framework)
const agentBuilderStub = env.AGENT_BUILDER.get(
  env.AGENT_BUILDER.idFromString('agentbuilder-singleton')
)
```

## DurableThread Schema

Each DurableThread has its own SQLite database with the following tables:

### messages Table

Stores the conversation history in OpenAI format:

```sql
CREATE TABLE messages (
  id TEXT PRIMARY KEY,
  role TEXT CHECK(role IN ('system', 'user', 'assistant', 'tool')),
  content TEXT,
  name TEXT,
  tool_calls TEXT,              -- JSON array of tool calls
  tool_call_id TEXT,
  reasoning_content TEXT,        -- For o1/o3 models
  status TEXT,                   -- pending | completed | failed
  silent BOOLEAN,
  tool_status TEXT,              -- success | error
  parent_id TEXT,                -- For sub-prompt messages
  depth INTEGER,                 -- Nesting level (0 = top-level)
  created_at INTEGER NOT NULL,   -- Microseconds since epoch
  FOREIGN KEY (parent_id) REFERENCES messages(id)
)
```

**Message Hierarchy:**
- **Top-level messages** (`depth=0`, `parent_id=NULL`): Main conversation visible to parent LLM
- **Sub-prompt messages** (`depth=1+`, `parent_id=messageId`): Messages from tool-executed prompts

### tool_calls Table

Denormalized tool call details for quick querying:

```sql
CREATE TABLE tool_calls (
  id TEXT PRIMARY KEY,
  message_id TEXT NOT NULL,
  type TEXT DEFAULT 'function',
  function_name TEXT NOT NULL,
  function_arguments TEXT NOT NULL,
  created_at INTEGER NOT NULL,
  FOREIGN KEY (message_id) REFERENCES messages(id) ON DELETE CASCADE
)
```

### logs Table

Ephemeral telemetry data (can be truncated without affecting functionality):

```sql
CREATE TABLE logs (
  id TEXT PRIMARY KEY,
  message_id TEXT NOT NULL,
  provider TEXT NOT NULL,
  model TEXT NOT NULL,
  endpoint TEXT,
  request_body TEXT,
  request_headers TEXT,
  response_body TEXT,
  response_headers TEXT,
  status_code INTEGER,
  input_tokens INTEGER,
  cached_tokens INTEGER,
  output_tokens INTEGER,
  total_tokens INTEGER,
  latency_ms INTEGER,
  time_to_first_token_ms INTEGER,
  finish_reason TEXT,
  error TEXT,
  error_type TEXT,
  cost_input REAL,
  cost_output REAL,
  cost_total REAL,
  message_history_length INTEGER,
  tools_available INTEGER,
  created_at INTEGER NOT NULL,
  FOREIGN KEY (message_id) REFERENCES messages(id) ON DELETE CASCADE
)
```

### execution_state Table

Key-value store for execution state:

```sql
CREATE TABLE execution_state (
  key TEXT PRIMARY KEY,
  value TEXT NOT NULL
)
```

Stores:
- `turn_count` - Current turn number
- `stopped` - Whether execution is stopped
- `stopped_by` - Which side stopped (for dual_ai)
- `current_side` - Active side (a or b)

## DurableAgentBuilder Schema

The singleton DurableAgentBuilder has a single table:

### threads Table

Thread metadata and registry:

```sql
CREATE TABLE threads (
  id TEXT PRIMARY KEY,
  agent_id TEXT NOT NULL,
  user_id TEXT,
  created_at INTEGER NOT NULL,
  updated_at INTEGER NOT NULL,
  tags TEXT                      -- JSON array of tags
)
```

## DurableObject SQL API

<Warning>
The DurableObject SQL API returns an **iterator/cursor**, NOT a result object with a `.rows` property!
</Warning>

### Correct Usage

```typescript
// ✅ CORRECT - Iterate directly with for...of
const cursor = await storage.sql.exec(`SELECT id, content FROM messages`)
for (const row of cursor) {
  console.log(row.id, row.content) // Access columns by name
}

// ✅ CORRECT - Convert to array for array methods
const cursor = await storage.sql.exec(`SELECT id, content FROM messages`)
const rows = cursor.toArray()
const messages = rows.map((row) => ({
  id: row.id,           // Access by column name
  content: row.content, // NOT by index!
}))

// ✅ CORRECT - Spread into array
const cursor = await storage.sql.exec(`SELECT * FROM messages`)
const rows = [...cursor]
```

### Incorrect Usage

```typescript
// ❌ WRONG - .rows does not exist on cursor!
const result = await storage.sql.exec(`SELECT * FROM messages`)
const messages = (result.rows || []).map(...)  // result.rows is undefined!

// ❌ WRONG - Cannot call .map() directly on cursor
const cursor = await storage.sql.exec(`SELECT * FROM messages`)
const messages = cursor.map(row => ({ ... }))  // .map() doesn't exist!

// ❌ WRONG - Rows are objects, not arrays! Cannot access by index!
const cursor = await storage.sql.exec(`SELECT id, content FROM messages`)
const rows = cursor.toArray()
const messages = rows.map(row => ({
  id: row[0],        // WRONG! Returns undefined
  content: row[1]    // WRONG! Returns undefined
}))
```

### Common Patterns

<Tabs>
  <Tab title="Single row query">
    ```typescript
    const cursor = await storage.sql.exec(
      `SELECT value FROM metadata WHERE key = ?`,
      'version'
    )
    const rows = cursor.toArray()
    const value = rows[0]?.value  // Access by column name
    ```
  </Tab>

  <Tab title="Multiple rows with for...of">
    ```typescript
    const cursor = await storage.sql.exec(
      `SELECT id, name, email FROM users`
    )
    const users = []
    for (const row of cursor) {
      users.push({
        id: row.id as string,      // Access by column name
        name: row.name as string,
        email: row.email as string
      })
    }
    ```
  </Tab>

  <Tab title="Multiple rows with toArray">
    ```typescript
    const cursor = await storage.sql.exec(
      `SELECT id, name, email FROM users`
    )
    const rows = cursor.toArray()  // Convert to array first
    const users = rows.map(row => ({
      id: row.id as string,          // Access by column name
      name: row.name as string,
      email: row.email as string
    }))
    ```
  </Tab>

  <Tab title="Count query">
    ```typescript
    const cursor = await storage.sql.exec(
      `SELECT COUNT(*) as count FROM messages`
    )
    const rows = cursor.toArray()
    const count = rows[0]?.count ?? 0  // Access by alias name
    ```
  </Tab>
</Tabs>

## Migration System

Durable Objects support schema migrations to evolve your database over time.

### Defining Migrations

Migrations are defined in `wrangler.jsonc`:

```jsonc
{
  "migrations": [
    {
      "tag": "v1",
      "new_sqlite_classes": ["DurableThread", "DurableAgentBuilder"]
    },
    {
      "tag": "v2",
      "deleted_classes": ["OldDurableObject"]
    }
  ]
}
```

### Migration Types

| Type | Description |
|------|-------------|
| `new_classes` | Create new Durable Object classes |
| `new_sqlite_classes` | Create new Durable Object classes with SQLite |
| `renamed_classes` | Rename existing classes |
| `deleted_classes` | Delete existing classes |

### Running Migrations

Migrations run automatically when:
1. You deploy to Cloudflare Workers
2. The migration tag doesn't match the stored migration ID

```typescript
// Check migration status (done automatically by framework)
class DurableThread {
  async ensureMigrated(storage: DurableObjectStorage) {
    const migrated = await storage.get('schema_version')
    if (migrated !== 'v1') {
      await this.runMigrations(storage)
      await storage.put('schema_version', 'v1')
    }
  }

  async runMigrations(storage: DurableObjectStorage) {
    // Run schema creation/updates
    await storage.sql.exec(`
      CREATE TABLE IF NOT EXISTS messages (...)
    `)
  }
}
```

## RPC Methods

Durable Objects support Remote Procedure Calls (RPC) for external access.

### DurableThread RPC Methods

```typescript
class DurableThread {
  // Process a new message
  async processMessage(content: string, role: string): Promise<Message>

  // Get message history
  async getMessages(
    limit?: number,
    offset?: number,
    order?: 'asc' | 'desc',
    depth?: number
  ): Promise<Message[]>

  // Get execution logs
  async getLogs(
    limit?: number,
    offset?: number,
    order?: 'asc' | 'desc'
  ): Promise<Log[]>

  // Stop execution
  async stopExecution(): Promise<void>

  // Get thread metadata
  async getMetadata(): Promise<ThreadMetadata>
}
```

### DurableAgentBuilder RPC Methods

```typescript
class DurableAgentBuilder {
  // Create a new thread
  async createThread(agentId: string, userId?: string): Promise<string>

  // Get thread metadata
  async getThread(threadId: string): Promise<ThreadMetadata | null>

  // List threads with filtering
  async listThreads(
    userId?: string,
    limit?: number,
    offset?: number
  ): Promise<ThreadMetadata[]>

  // Delete a thread
  async deleteThread(threadId: string): Promise<void>

  // Update thread tags
  async updateThreadTags(threadId: string, tags: string[]): Promise<void>
}
```

## Accessing Durable Objects

### From API Routes

```typescript
import { defineController } from '@agentbuilder/vite'

export default defineController(async (request, env) => {
  const threadId = 'some-thread-id'

  // Get DurableThread stub
  const threadStub = env.AGENT_BUILDER_THREAD.get(
    env.AGENT_BUILDER_THREAD.idFromString(threadId)
  )

  // Call RPC method
  const messages = await threadStub.getMessages()

  return new Response(JSON.stringify(messages), {
    headers: { 'Content-Type': 'application/json' }
  })
})
```

### From Tools

Tools receive a `flow` object with access to the current thread's storage:

```typescript
import { defineTool } from '@agentbuilder/vite'
import { z } from 'zod'

export default defineTool(
  'Read custom data from thread storage',
  z.object({}),
  async (flow) => {
    // Access thread's SQLite database
    const cursor = await flow.storage.sql.exec(
      `SELECT * FROM custom_table`
    )
    const rows = cursor.toArray()

    return {
      status: 'success',
      result: JSON.stringify(rows)
    }
  }
)
```

## Performance Considerations

<CardGroup cols={2}>
  <Card title="Message History Loading" icon="clock">
    Only load necessary messages. Consider pagination for very long threads (>1000 messages).
  </Card>

  <Card title="Index Your Queries" icon="database">
    Add indexes for frequently queried columns:
    ```sql
    CREATE INDEX idx_messages_created
    ON messages(created_at)
    ```
  </Card>

  <Card title="Log Pruning" icon="trash">
    Periodically truncate old logs (they're ephemeral):
    ```sql
    DELETE FROM logs
    WHERE created_at < ?
    ```
  </Card>

  <Card title="Connection Pooling" icon="network">
    WebSocket connections are pooled per Durable Object instance. Clean up on disconnect.
  </Card>
</CardGroup>

## Best Practices

<AccordionGroup>
  <Accordion title="Use transactions for related writes">
    ```typescript
    // Group related inserts in a transaction
    await storage.sql.exec(`BEGIN TRANSACTION`)
    try {
      await storage.sql.exec(`INSERT INTO messages (...)`)
      await storage.sql.exec(`INSERT INTO tool_calls (...)`)
      await storage.sql.exec(`COMMIT`)
    } catch (error) {
      await storage.sql.exec(`ROLLBACK`)
      throw error
    }
    ```
  </Accordion>

  <Accordion title="Access columns by name, never by index">
    ```typescript
    // ✅ CORRECT
    const row = rows[0]
    const id = row.id

    // ❌ WRONG
    const id = row[0]  // Returns undefined!
    ```
  </Accordion>

  <Accordion title="Use toArray() for array methods">
    ```typescript
    // ✅ CORRECT
    const cursor = await storage.sql.exec(`SELECT * FROM messages`)
    const rows = cursor.toArray()
    const filtered = rows.filter(row => row.role === 'user')

    // ❌ WRONG
    const filtered = cursor.filter(row => row.role === 'user')
    ```
  </Accordion>

  <Accordion title="Store JSON as TEXT, parse on read">
    ```typescript
    // Store
    await storage.sql.exec(
      `INSERT INTO messages (tool_calls) VALUES (?)`,
      JSON.stringify(toolCalls)
    )

    // Read
    const cursor = await storage.sql.exec(`SELECT tool_calls FROM messages`)
    const rows = cursor.toArray()
    const toolCalls = JSON.parse(rows[0].tool_calls)
    ```
  </Accordion>

  <Accordion title="Use microsecond timestamps for precision">
    ```typescript
    const timestamp = Date.now() * 1000  // Convert to microseconds

    await storage.sql.exec(
      `INSERT INTO messages (created_at) VALUES (?)`,
      timestamp
    )
    ```
  </Accordion>
</AccordionGroup>

## Debugging

### Check Schema Version

```typescript
const cursor = await storage.sql.exec(
  `SELECT value FROM execution_state WHERE key = 'schema_version'`
)
const rows = cursor.toArray()
console.log('Schema version:', rows[0]?.value)
```

### Inspect Tables

```typescript
// List all tables
const cursor = await storage.sql.exec(
  `SELECT name FROM sqlite_master WHERE type='table'`
)
const tables = cursor.toArray()
console.log('Tables:', tables)

// Get table schema
const cursor = await storage.sql.exec(
  `PRAGMA table_info(messages)`
)
const schema = cursor.toArray()
console.log('Messages schema:', schema)
```

### Query Message Count

```typescript
const cursor = await storage.sql.exec(
  `SELECT COUNT(*) as count FROM messages`
)
const rows = cursor.toArray()
console.log('Message count:', rows[0]?.count)
```

## Related Documentation

<CardGroup cols={2}>
  <Card title="Builder Overview" icon="cube" href="/packages/builder/overview">
    Core framework documentation
  </Card>
  <Card title="Virtual Modules" icon="code" href="/packages/builder/virtual-modules">
    Auto-discovery system
  </Card>
  <Card title="Cloudflare Docs" icon="cloud" href="https://developers.cloudflare.com/durable-objects/">
    Official Durable Objects documentation
  </Card>
  <Card title="Admin UI" icon="desktop" href="/packages/builder/admin-ui">
    Built-in admin interface
  </Card>
</CardGroup>
