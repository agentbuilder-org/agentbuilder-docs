---
title: 'FlowState Utilities'
description: 'Runtime utilities for working with agent execution context'
---

## What is FlowState?

FlowState is the central state object that flows through the entire execution lifecycle of an agent. It contains all the information about the current execution: conversation history, tool calls, configuration, storage access, and more.

<Card title="Key Concept" icon="diagram-project">
  FlowState is available in **tool handlers** and **hooks**, providing a complete view of the execution context and utilities to modify it.
</Card>

## Core Components

<CardGroup cols={2}>
  <Card title="Identity" icon="fingerprint">
    Thread ID, Flow ID, execution tracking
  </Card>
  <Card title="Configuration" icon="gear">
    Agent config, current side, turn count
  </Card>
  <Card title="Messages" icon="messages">
    Full conversation history
  </Card>
  <Card title="Tools" icon="wrench">
    Tool queue, execution state
  </Card>
  <Card title="Storage" icon="database">
    DurableObject SQLite access
  </Card>
  <Card title="Streaming" icon="wifi">
    HTTP and WebSocket managers
  </Card>
</CardGroup>

## FlowState Interface

```typescript
interface FlowState {
  // Identity
  threadId: string;              // Unique thread identifier
  flowId: string;                // Unique flow execution identifier

  // Thread reference
  thread: {
    instance: ThreadInstance;    // DurableObject instance
    metadata: ThreadMetadata;    // Thread metadata
  };

  // Configuration
  agentConfig: Agent;            // Complete agent configuration
  currentSide: "a" | "b";        // Current executing side

  // Execution tracking
  turnCount: number;             // Current turn number (max 25)
  stopped: boolean;              // Whether execution should stop
  stoppedBy?: "a" | "b";         // Which side triggered stop

  // Message context
  messageHistory: Message[];     // Full conversation history

  // Tool execution queue
  sequence: {
    queue: ToolCall[];           // Pending tool calls
    isHandling: boolean;         // Currently processing queue
  };

  // Storage & environment
  storage: DurableObjectStorage; // DurableObject SQLite storage
  env: ThreadEnv;                // Cloudflare environment bindings

  // Runtime context
  context: Record<string, unknown>; // Arbitrary state data

  // Hierarchical tracking (for sub-prompts)
  rootState?: FlowState;         // Reference to root FlowState
  isChildPrompt?: boolean;       // Is this a sub-prompt execution?
}
```

## Utility Functions

All utility functions are imported from `@standardagents/builder`:

```typescript
import {
  queueTool,
  injectMessage,
  getMessages,
  reloadHistory,
  emitThreadEvent,
  forceTurn,
} from "@standardagents/builder";
```

### queueTool

Queue a new tool call to be executed in the current flow.

```typescript
queueTool(
  flow: FlowState,
  toolName: string,
  args?: Record<string, unknown>
): void
```

**Parameters:**
- `flow`: The current FlowState context
- `toolName`: The name of the tool to call
- `args`: Optional arguments to pass to the tool

**Example:**

```typescript
import { defineTool, queueTool } from "@standardagents/builder";
import { z } from "zod";

export default defineTool(
  "Process user order and send confirmation",
  z.object({
    orderId: z.string(),
    userId: z.string(),
  }),
  async (flow, args) => {
    // Validate the order
    const order = await validateOrder(args.orderId);

    if (!order.valid) {
      return {
        status: "error",
        error: "Order validation failed",
      };
    }

    // Queue additional tools to execute after this one
    queueTool(flow, "charge_payment", {
      orderId: args.orderId,
      amount: order.total,
    });

    queueTool(flow, "send_confirmation_email", {
      userId: args.userId,
      orderId: args.orderId,
    });

    queueTool(flow, "update_inventory", {
      items: order.items,
    });

    return {
      status: "success",
      result: `Order ${args.orderId} queued for processing`,
    };
  }
);
```

<Tip>
  **Sub-Prompts**: When calling `queueTool` from within a sub-prompt, use `flow.rootState` instead of `flow` to queue tools in the root execution context.

  ```typescript
  if (flow.isChildPrompt && flow.rootState) {
    queueTool(flow.rootState, "some_tool", args);
  }
  ```
</Tip>

---

### injectMessage

Inject a message into the thread without triggering agent execution.

```typescript
async injectMessage(
  flow: FlowState,
  options: InjectMessageOptions
): Promise<Message>
```

**Options:**

```typescript
interface InjectMessageOptions {
  content: string;                    // Message content
  role: "system" | "user" | "assistant" | "tool";
  id?: string;                        // Optional custom message ID
  beforeMessageId?: string;           // Insert before this message
  toolCallId?: string;                // For role="tool" only
  name?: string;                      // Optional name field
  silent?: boolean;                   // Hidden from LLM
  forceTopLevel?: boolean;            // Force depth 0
}
```

**Examples:**

<Tabs>
  <Tab title="System Context">
    ```typescript
    import { defineTool, injectMessage } from "@standardagents/builder";
    import { z } from "zod";

    export default defineTool(
      "Load user context",
      z.object({ userId: z.string() }),
      async (flow, args) => {
        const user = await fetchUser(args.userId);

        await injectMessage(flow, {
          role: "system",
          content: `User context loaded: ${user.name} (${user.email})
            - Account tier: ${user.tier}
            - Preferences: ${JSON.stringify(user.preferences)}`,
        });

        return {
          status: "success",
          result: "User context injected",
        };
      }
    );
    ```
  </Tab>
  <Tab title="Silent Message">
    ```typescript
    import { defineTool, injectMessage } from "@standardagents/builder";
    import { z } from "zod";

    export default defineTool(
      "Add internal note",
      z.object({ note: z.string() }),
      async (flow, args) => {
        await injectMessage(flow, {
          role: "system",
          content: args.note,
          silent: true,  // Hidden from LLM, visible in UI only
        });

        return {
          status: "success",
          result: "Internal note added",
        };
      }
    );
    ```
  </Tab>
</Tabs>

---

### getMessages

Retrieve message history from the thread's storage.

```typescript
async getMessages(
  flow: FlowState,
  limit?: number,
  offset?: number,
  order?: "asc" | "desc"
): Promise<Message[]>
```

**Parameters:**
- `flow`: The current FlowState context
- `limit`: Maximum number of messages (default: 100)
- `offset`: Number of messages to skip (default: 0)
- `order`: Sort order - `"asc"` or `"desc"` (default: `"asc"`)

**Example:**

```typescript
import { defineTool, getMessages } from "@standardagents/builder";

export default defineTool(
  "Analyze recent conversation tone",
  async (flow) => {
    // Get last 10 messages
    const messages = await getMessages(flow, 10);

    // Filter user and assistant messages only
    const conversationMessages = messages.filter(
      (m) => m.role === "user" || m.role === "assistant"
    );

    const tone = analyzeTone(conversationMessages);

    return {
      status: "success",
      result: `Conversation tone: ${tone}`,
    };
  }
);
```

---

### reloadHistory

Reload message history from storage, applying all filtering hooks.

```typescript
async reloadHistory(flow: FlowState): Promise<Message[]>
```

**Example:**

```typescript
import { defineTool, reloadHistory } from "@standardagents/builder";

export default defineTool(
  "Refresh conversation history",
  async (flow) => {
    const messages = await reloadHistory(flow);

    return {
      status: "success",
      result: `Reloaded ${messages.length} messages`,
    };
  }
);
```

---

### emitThreadEvent

Send custom events to WebSocket clients.

```typescript
emitThreadEvent(
  flow: FlowState,
  type: string,
  data: unknown
): void
```

**Parameters:**
- `flow`: The current FlowState context
- `type`: The event type name
- `data`: The event payload data

**Event Structure:**

```json
{
  "type": "event",
  "eventType": "<your-type>",
  "data": <your-data>,
  "timestamp": 1234567890
}
```

**Examples:**

<Tabs>
  <Tab title="Progress Updates">
    ```typescript
    import { defineTool, emitThreadEvent } from "@standardagents/builder";
    import { z } from "zod";

    export default defineTool(
      "Process large dataset",
      z.object({ datasetId: z.string() }),
      async (flow, args) => {
        const dataset = await loadDataset(args.datasetId);
        const total = dataset.length;

        for (let i = 0; i < total; i++) {
          await processItem(dataset[i]);

          // Emit progress event
          emitThreadEvent(flow, "progress", {
            current: i + 1,
            total,
            percentage: ((i + 1) / total) * 100,
            message: `Processing item ${i + 1} of ${total}`,
          });
        }

        return {
          status: "success",
          result: `Processed ${total} items`,
        };
      }
    );
    ```
  </Tab>
  <Tab title="Status Updates">
    ```typescript
    import { defineTool, emitThreadEvent } from "@standardagents/builder";
    import { z } from "zod";

    export default defineTool(
      "Upload file",
      z.object({ fileUrl: z.string() }),
      async (flow, args) => {
        emitThreadEvent(flow, "upload-status", {
          status: "started",
          message: "Starting download...",
        });

        const file = await downloadFile(args.fileUrl);

        emitThreadEvent(flow, "upload-status", {
          status: "processing",
          message: "Processing file...",
        });

        const result = await processFile(file);

        emitThreadEvent(flow, "upload-status", {
          status: "complete",
          message: "Upload complete!",
        });

        return {
          status: "success",
          result: "File processed",
        };
      }
    );
    ```
  </Tab>
</Tabs>

---

### forceTurn

Force the next execution to a specific side.

```typescript
forceTurn(flow: FlowState, side: "a" | "b"): void
```

**Parameters:**
- `flow`: The current FlowState context
- `side`: The side to force next turn to (`"a"` or `"b"`)

<Note>
  This is primarily used for dual_ai agents to control turn order.
</Note>

## Complete Example

Here's a comprehensive example showing multiple utilities working together:

```typescript
import {
  defineTool,
  queueTool,
  injectMessage,
  emitThreadEvent,
  getMessages,
} from "@standardagents/builder";
import { z } from "zod";

export default defineTool(
  "Complete order processing workflow",
  z.object({
    orderId: z.string(),
    userId: z.string(),
    notifyUser: z.boolean().default(true),
  }),
  async (flow, args) => {
    // Emit initial status event
    emitThreadEvent(flow, "order-status", {
      orderId: args.orderId,
      status: "started",
    });

    // Inject system message for context
    await injectMessage(flow, {
      role: "system",
      content: `Processing order ${args.orderId} for user ${args.userId}`,
    });

    // Queue validation tool
    queueTool(flow, "validate_order", {
      orderId: args.orderId,
    });

    // Queue payment processing
    queueTool(flow, "process_payment", {
      orderId: args.orderId,
      userId: args.userId,
    });

    // Queue inventory update
    queueTool(flow, "update_inventory", {
      orderId: args.orderId,
    });

    // Conditionally queue notification
    if (args.notifyUser) {
      queueTool(flow, "send_notification", {
        userId: args.userId,
        type: "order_confirmation",
        orderId: args.orderId,
      });
    }

    // Get conversation history for audit
    const messages = await getMessages(flow, 50);
    const orderMessages = messages.filter(
      (m) => m.content?.includes(args.orderId)
    );

    // Emit completion event
    emitThreadEvent(flow, "order-status", {
      orderId: args.orderId,
      status: "queued",
      steps: 4,
      relatedMessages: orderMessages.length,
    });

    return {
      status: "success",
      result: `Order ${args.orderId} workflow initiated`,
    };
  }
);
```

## Frontend Integration

Listen for events on the frontend using `onThreadEvent` from `@standardagents/react`:

```tsx
import {
  StandardAgentsProvider,
  ThreadProvider,
  onThreadEvent,
} from "@standardagents/react";

function App() {
  return (
    <StandardAgentsProvider config={{ endpoint: "https://api.example.com" }}>
      <ThreadProvider threadId="thread-123" live={true}>
        <OrderTracker />
      </ThreadProvider>
    </StandardAgentsProvider>
  );
}

function OrderTracker() {
  // Listen for order status events
  const orderStatus = onThreadEvent<{
    orderId: string;
    status: string;
    steps?: number;
  }>("order-status");

  // Listen for progress events
  const progress = onThreadEvent<{
    current: number;
    total: number;
    percentage: number;
  }>("progress");

  return (
    <div>
      {orderStatus && (
        <div>
          Order {orderStatus.orderId}: {orderStatus.status}
        </div>
      )}

      {progress && (
        <progress value={progress.percentage} max={100} />
      )}
    </div>
  );
}
```

## Best Practices

<AccordionGroup>
  <Accordion title="Error Handling">
    Always wrap async utility calls in try-catch blocks:

    ```typescript
    try {
      await injectMessage(flow, {
        role: "system",
        content: "Context updated",
      });
    } catch (error) {
      console.error("Failed to inject message:", error);
      return {
        status: "error",
        error: `Message injection failed: ${error.message}`,
      };
    }
    ```
  </Accordion>

  <Accordion title="Throttle Event Emissions">
    Avoid excessive event emissions that could overwhelm WebSocket clients:

    ```typescript
    // Good: Throttle emissions
    for (let i = 0; i < 10000; i++) {
      if (i % 100 === 0) {
        emitThreadEvent(flow, "progress", {
          current: i,
          total: 10000,
        });
      }
    }

    // Avoid: Emitting inside tight loop
    for (let i = 0; i < 10000; i++) {
      emitThreadEvent(flow, "progress", { value: i });
    }
    ```
  </Accordion>

  <Accordion title="Message Pagination">
    When retrieving large message histories, use pagination:

    ```typescript
    const pageSize = 50;
    let offset = 0;
    let hasMore = true;

    while (hasMore) {
      const messages = await getMessages(flow, pageSize, offset);
      await processMessages(messages);
      hasMore = messages.length === pageSize;
      offset += pageSize;
    }
    ```
  </Accordion>

  <Accordion title="Tool Queue Management">
    Be mindful of tool queue depth to avoid excessive chaining:

    ```typescript
    const currentQueueDepth = flow.sequence.queue.length;

    if (currentQueueDepth < 10) {
      queueTool(flow, "additional_tool", {});
    } else {
      await injectMessage(flow, {
        role: "system",
        content: "Tool queue depth exceeded, deferring processing",
      });
    }
    ```
  </Accordion>
</AccordionGroup>

## Common Types

### Message

```typescript
interface Message {
  id: string;
  role: "system" | "user" | "assistant" | "tool";
  content: string | null;
  name?: string | null;
  tool_calls?: string | null;
  tool_call_id?: string | null;
  log_id?: string | null;
  created_at: number;
  status?: "pending" | "completed" | "failed";
  silent?: boolean;
  depth?: number;
}
```

### ToolCall

```typescript
interface ToolCall {
  id: string;
  type: "function";
  function: {
    name: string;
    arguments: string; // JSON string
  };
}
```

## Troubleshooting

<AccordionGroup>
  <Accordion title="Events not received by frontend">
    **Solution:** Ensure you're using `ThreadProvider` with `live={true}` and that `onThreadEvent` is called with the correct event type name.
  </Accordion>

  <Accordion title="Tool not executing after queueTool">
    **Solution:** Tools are queued for sequential execution. Ensure the current tool completes successfully and doesn't stop execution.
  </Accordion>

  <Accordion title="getMessages returns empty array">
    **Solution:** Check that messages exist in the thread storage and that limit/offset parameters are correct.
  </Accordion>
</AccordionGroup>

## Next Steps

<CardGroup cols={2}>
  <Card title="Tools API" icon="wrench" href="/api-reference/tools">
    Create custom tools that use FlowState
  </Card>
  <Card title="Hooks" icon="hook" href="/core-concepts/hooks">
    Use FlowState in lifecycle hooks
  </Card>
  <Card title="React Integration" icon="react" href="/react/overview">
    Connect frontend to backend events
  </Card>
  <Card title="Examples" icon="sparkles" href="/examples">
    See FlowState utilities in action
  </Card>
</CardGroup>
